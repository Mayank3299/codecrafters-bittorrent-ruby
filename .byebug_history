q
n
s
n
s
n
q
e
n
block_data
piece_offset
n
message
n
s
n
s
n
q
s
n
piece_data
piece_dat
n
s
payload
n
length
n
offset
s
current_piece_length
no_of_pieces
total_length
piece_length
n
piece_length
n
s
n
message_id
socket
s
n
message
n
length
n
s
n
piece_index
outout_path
info_hash
socket
q
e
n
piece_data
n
q
piece_index < no_of_pieces
  no_of_pieces = (info_hash['pieces'].bytesize / 20) - 1 # Pieces with length 20
  total_length = info_hash['length']
  piece_length = info_hash['piece length']
piece_index
info_hash
socket
q
e
n
e
n
piece_index
output_path
info_hash
socket
q
info
socket
q
piece_index
piece
output_path
decoded_str['info']
socket
q
info_dict['pieces'].unpack1('H*').scan(/.{40}/)
a = "\x00" * 5
[1,2,3][1,2]
[1,2,3][1]
(0...current_piece_length).step(BLOCK_SIZE) do |offset|
    length = [BLOCK_SIZE, current_piece_length - offset].min
    puts payload = [piece_index, offset, length]
    # Send request message
    # send_peer_message(socket, BITTORRENT_MESSAGE_ID_HASH['request'], payload: payload)
  end
(0...current_piece_length).step(BLOCK_SIZE) do |offset|
    length = [BLOCK_SIZE, current_piece_length - offset].min
    puts payload = [piece_index, offset, length].pack('N3')
    # Send request message
    # send_peer_message(socket, BITTORRENT_MESSAGE_ID_HASH['request'], payload: payload)
  end
  total_blocks = num_full_blocks + (last_block_size.positive? ? 1 : 0)
  last_block_size = current_piece_length % BLOCK_SIZE
  num_full_blocks = current_piece_length / BLOCK_SIZE
BLOCK_SIZE = 16 * 1024 # 16 KB = 16,384
  current_piece_length = piece_index < no_of_pieces ? piece_length : total_length - no_of_pieces * piece_length
piece_index = 1
no_of_pieces = (info_dict['pieces'].bytesize / 20) - 1 # Pieces with length 20
 total_length = info_dict['length']
piece_length = info_dict['piece length']
  total_length = info_dict['length']
  no_of_pieces = (info_dict['pieces'].bytesize / 20) - 1 # Pieces with length 20
  current_piece_length = piece_index < no_of_pieces ? piece_length : total_length - no_of_pieces * piece_length
info_dict['pieces'].unpack1('H*').scan(/.{40}/)
pieces
piece_index
  no_of_pieces = (info_dict['pieces'].bytesize / 20) - 1 # Pieces with length 20
  total_length = info_dict['length']
  piece_length = info_dict['piece length']
info_dict['pieces'].length/20
info_dict['pieces'].bytesize/20
info_dict['pieces'].bytesize
92063 / 32768.0
92063 / 32768
info_dict['pieces'].unpack1('H*').scan(/.{40}/)
info_dict
q
y
q
  message = length + [id].pack('C') + payload
id = 5
  length = [1 + payload.bytesize].pack('N')
payload = ''
[2].pack('N')
2.pack('N')
remaining_message.unpack('C*').last.to_s(2)
remaining_message.unpack('C*').last.to_binary
remaining_message.unpack('C*').last
remaining_message.unpack('C*')
remaining_message.unpack('C')
remaining_message
remaining_message.first
  remaining_message = socket.read(message_length)
  message_length = socket.read(4).unpack1('N*')
q
socket.read(2)
  message_length = socket.read(4).unpack1('N*')
q
message_length = message_length.unpack1('N*')
  message_length = socket.read(4)
message_length.unpack1('N*')
message_length.unpack('N*')
socket.read(message_length)
message_length.unpack('N*')
message_length.unpack('N')
message_length.bytesize
message_length.byesize
message_length.length
  message_length = socket.read(4)
q
message_length = _
socket.read(4)
q
socket
info_hash
peer_info_hash
hex_peer_id
q
info_hash
response[28..47]
response[28..47].bytesize
response[28..48].bytesize
response[28..48]
response
q
n
decoded_str
q
  info_hash = Digest::SHA1.digest(encoded_info)
  encoded_info = encode_bencode(decoded_str['info'])
  decoded_str, = decode_bencode(encoded_str)
  encoded_str = File.binread(torrent_path)
torrent_path = 'sample.torrent'
[214, 159, 145, 230, 178, 174, 76, 84, 36, 104, 209, 7, 58, 113, 212, 234, 19, 135, 154, 127].pack('H*')
[214, 159, 145, 230, 178, 174, 76, 84, 36, 104, 209, 7, 58, 113, 212, 234, 19, 135, 154, 127].pack
info_hash.unpack('C*')
info_hash.unpack
info_hash
n
q
ARGV
n
url
n
params = {
    'info_hash' => info_hash,
    'peer_id' => peer_id,
    'port' => 6681,
    'uploaded' => 0,
    'downloaded' => 0,
    'left' => decoded_str['info']['files'].first['length'],
    'compact' => 1
  }
decoded_str['info']['files']
decoded_str['info']
params
n
info_hash
n
url.to_s
url
n
decoded_str
n
encoded_str
n
torrent_path
n
q
"#{data.length}:#{data}"
data = :name
key.length
val.length
val
value
key
q
n
q
n
data.class
n
q
decoded_str
n
encoded_str
n
q
File.binread(torrent_path)
File.binread(torrent_path
torrent_path
q
